<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">0</article-id>
<article-id pub-id-type="doi">N/A</article-id>
<title-group>
<article-title>GixPy: A Python package for transforming grazing
incidence X-ray scattering images</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<name>
<surname>Tortorici</surname>
<given-names>Edward</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Rogers</surname>
<given-names>Charles T.</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Department of Physics, University of Colorado
Boulder</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2024-11-22">
<day>22</day>
<month>11</month>
<year>2024</year>
</pub-date>
<volume>¿VOL?</volume>
<issue>¿ISSUE?</issue>
<fpage>¿PAGE?</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>1970</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Python</kwd>
<kwd>X-ray</kwd>
<kwd>X-ray diffraction</kwd>
<kwd>XRD</kwd>
<kwd>grazing incidence</kwd>
<kwd>GIXS</kwd>
<kwd>GIWAXS</kwd>
<kwd>GISAXS</kwd>
<kwd>GIXD</kwd>
<kwd>educational</kwd>
<kwd>thin films</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Grazing incidence X-ray scattering techniques are used to
  investigate the crystal structure and orientation of crystallites in
  thin films
  (<xref alt="Steele et al., 2023" rid="ref-how-to-giwaxs" ref-type="bibr">Steele
  et al., 2023</xref>). Often area detectors are used to measure the
  resulting interference pattern, which requires images to be
  transformed such that the axes represent reciprocal space. X-ray image
  analysis software often assumes that the sample is a powder. However,
  for grazing incidence X-ray experiments, if crystallites in the film
  have a preferred orientation, the image manipulation requires
  additional considerations.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>There currently exists many tools for transforming wide-angle X-ray
  scattering (WAXS) and small-angle X-ray scattering (SAXS) images into
  reciprocal space, including pyFAI
  (<xref alt="Kieffer &amp; Ashiotis, 2013" rid="ref-pyfai" ref-type="bibr">Kieffer
  &amp; Ashiotis, 2013</xref>) and Nika
  (<xref alt="Ilavsky, 2012" rid="ref-nika" ref-type="bibr">Ilavsky,
  2012</xref>). However, these tools lack the capability of processing
  raw images from grazing incidence wide/small-angle X-ray scattering
  (GIWAXS/GISAXS) experiments. Here we refer to both GIWAXS and GISAXS
  as grazing incidence X-ray scattering (GIXS). An existing tool,
  <ext-link ext-link-type="uri" xlink:href="https://github.com/tgdane/pygix">pygix</ext-link>,
  is capable of processing GIWAXS and GISAXS images into reciprocal
  space. However, it lacks transparency, in that, the documentation is
  sparse, and it utilizes look-up tables to perform the transformation,
  making the source code difficult to parse. Furthermore, researchers
  interested in utilizing GIXS experiments likely already do powder
  X-ray experiments, and have a preferred suite of tools</p>
  <p>GixPy seeks transparency in order to serve not only as a useful
  tool, but also an educational tool for those who are less experienced
  with grazing incidence experiments. This goal is achieved by
  maintaining well documented and commented code that utilizes direct
  computation, and is written with source-code readability in mind. This
  is intended to allow students and researchers to have an accessible
  resource, with examples, that helps them learn how to process GIXS
  images and understand the necessity of this procedure.</p>
  <p>Furthermore, GixPy’s agnosticism allows it to be utilized as an
  intermediary step for anyone who already has a preferred WAXS/SAXS
  image processing software. This allows users to not need to learn an
  entirely new system to do their analysis in, and can simply use GixPy
  to pre-process an image before giving it to their preferred
  environment for analysis. However, since GixPy is built as a Python
  tool, it has been built to seamlessly integrate with pyFAI to serve as
  a complete processing tool.</p>
</sec>
<sec id="powder-transformation">
  <title>Powder transformation</title>
  <p>Existing tools, such as Nika and pyFAI transform images with the
  assumption that samples are a powder, such that the scattering results
  in Debye-Scherrer cones
  (<xref alt="Cullity &amp; Stock, 2014" rid="ref-cullity3rd" ref-type="bibr">Cullity
  &amp; Stock, 2014</xref>). A typical experimental setup is exemplified
  in Figure <xref alt="[fig:waxs]" rid="figU003Awaxs">[fig:waxs]</xref>.
  An area detector is used to intersect the Debye-Scherrer cones to
  detect rings of constructive interference.</p>
  <fig>
    <caption><p>A typical WAXS/SAXS experiment. A powder sample is
    exposed to an incident beam, resulting in Debye-Scherrer cones of
    constructive interference. An area detector is used to intersect the
    cones to detect
    rings.<styled-content id="figU003Awaxs"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="waxs.png" />
  </fig>
  <p>The scattering angle <inline-formula><alternatives>
  <tex-math><![CDATA[2\theta]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  can be related to reciprocal space through Bragg’s law:</p>
  <p><named-content id="eqU003Abragg" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[
      q = \frac{4\pi}{\lambda}\sin\theta,]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>4</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:mo>sin</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></named-content></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[\lambda]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>λ</mml:mi></mml:math></alternatives></inline-formula>
  is the wavelength of the scattered X-rays. The scattering angle can be
  determined from the radius of the ring on the detector
  <inline-formula><alternatives>
  <tex-math><![CDATA[r]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>r</mml:mi></mml:math></alternatives></inline-formula>
  and the sample-detector distance <inline-formula><alternatives>
  <tex-math><![CDATA[d_{sd}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\tan 2\theta = \frac{r}{d_{sd}},]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>tan</mml:mo><mml:mn>2</mml:mn><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>r</mml:mi><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>so a powder image transformation calculates
  <inline-formula><alternatives>
  <tex-math><![CDATA[q]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>q</mml:mi></mml:math></alternatives></inline-formula>
  from the ring radii using</p>
  <p><named-content id="eqU003Apowder" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[
      q = \frac{4\pi}{\lambda}\sin\bigg[\frac{1}{2}\tan^{-1}\bigg(\frac{r}{d_{sd}}\bigg)\bigg].]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>4</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:mo>sin</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">[</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mo>tan</mml:mo><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">(</mml:mo><mml:mfrac><mml:mi>r</mml:mi><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">)</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">]</mml:mo><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></named-content></p>
  <p>A GixPy transformation processes an image, such that a processed
  image can be transformed assuming powder symmetry will produce correct
  results.</p>
</sec>
<sec id="geometric-assumptions">
  <title>Geometric assumptions</title>
  <p>GixPy supports geometries where the incident beam is perpendicular
  to the detector and the sample is brought into the beam path (see
  Figure
  <xref alt="[fig:experimental-geometry]" rid="figU003Aexperimental-geometry">[fig:experimental-geometry]</xref>).
  This means that the point of normal incidence (PONI) on the detector
  and where the incident beam hits the detector (the beam center) are
  the same locations on the detector.</p>
  <p>The top-left pixel of the detector is the origin of the data array
  and defines the PONI as the distance from the bottom-left corner of
  the detector (consistent with pyFAI), as seen in Figure
  <xref alt="[fig:pixel-poni]" rid="figU003Apixel-poni">[fig:pixel-poni]</xref>.
  Transforming between <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{r}_{\text{poni}_{i,j}}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>𝐫</mml:mi><mml:msub><mml:mtext mathvariant="normal">poni</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{r}_\text{poni}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>𝐫</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub></mml:math></alternatives></inline-formula>
  can be done with the following relation:</p>
  <fig>
    <caption><p>The supported experimental geometry has the detector
    positioned surface normal to the incident beam, and the grazing
    angle is set by rotating the sample by
    <inline-formula><alternatives>
    <tex-math><![CDATA[\alpha_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    relative to the
    beam.<styled-content id="figU003Aexperimental-geometry"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="experimental-geometry.png" />
  </fig>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      \text{poni}_1 &= \bigg(R - i_\text{poni} - \frac{1}{2}\bigg)p_z\\
      \text{poni}_2 &= \bigg(j_\text{poni} + \frac{1}{2}\bigg)p_x,
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mtext mathvariant="normal">poni</mml:mtext><mml:mn>1</mml:mn></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">(</mml:mo><mml:mi>R</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mtext mathvariant="normal">poni</mml:mtext><mml:mn>2</mml:mn></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">)</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[R]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>R</mml:mi></mml:math></alternatives></inline-formula>
  is the number of rows in the image and <inline-formula><alternatives>
  <tex-math><![CDATA[p_x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[p_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>p</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  are the horizontal and vertical widths of a pixel respectively. This
  transformation can be done with</p>
  <code language="python">gixpy.poni.convert_to(poni_ij, pixel_widths, image_shape)</code>
  <p>and reversed with</p>
  <code language="python">gixpy.poni.convert_from(poni, pixel_widths, image_shape)</code>
  <p>Where each input can be a tuple, list, or NumPy array, with the
  first element being the vertical value and the second element being
  the horizontal value.</p>
  <fig>
    <caption><p>An example detector with <inline-formula><alternatives>
    <tex-math><![CDATA[10 \times 10]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    pixels. The PONI is described by the distance (in meters) from the
    bottom left corner. A user can convert a PONI in the
    <inline-formula><alternatives>
    <tex-math><![CDATA[(i_\text{poni}, j_{poni})]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    format using the <monospace>gixpy.poni.convert_to()</monospace>
    function.<styled-content id="figU003Apixel-poni"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="pixel-poni.png" />
  </fig>
</sec>
<sec id="scattering-geometry">
  <title>Scattering geometry</title>
  <p>In grazing incidence X-ray scattering, there is a very small angle,
  called the grazing angle or incident angle, between the plane of the
  film and the incident beam. The incident beam, with wavelength
  <inline-formula><alternatives>
  <tex-math><![CDATA[\lambda]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>λ</mml:mi></mml:math></alternatives></inline-formula>,
  has a wavevector <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{k}_i]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  with magnitude <inline-formula><alternatives>
  <tex-math><![CDATA[2\pi/\lambda]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>/</mml:mi><mml:mi>λ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
  Elastic scattering, due to bound electrons in the film, will result in
  a scattered ray with wavevector <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{k}_s]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  with the same magnitude. In the sample frame (Figure
  <xref alt="[fig:scattering-angles]" rid="figU003Ascattering-angles">[fig:scattering-angles]</xref>a),
  the axes are oriented such that the <inline-formula><alternatives>
  <tex-math><![CDATA[z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>z</mml:mi></mml:math></alternatives></inline-formula>-direction
  is surface-normal to the film plane, and the
  <inline-formula><alternatives>
  <tex-math><![CDATA[x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>-direction
  is perpendicular to the direction of the incident beam. In the sample
  frame, the direction of the scattered ray can be described by
  rotations from the <inline-formula><alternatives>
  <tex-math><![CDATA[y]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>y</mml:mi></mml:math></alternatives></inline-formula>-direction:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\mathbf{k}_s = \frac{2\pi}{\lambda} R_x(\alpha_s)R_z(\phi_s)\ \hat{y},]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.222em"></mml:mspace><mml:mover><mml:mi>y</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[\hat{y}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>y</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
  is the <inline-formula><alternatives>
  <tex-math><![CDATA[y]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>y</mml:mi></mml:math></alternatives></inline-formula>-direction
  in the sample frame. This is a non-conventional order of operations,
  but it leads to simplifications in the calculations. In the lab frame
  (see Figure
  <xref alt="[fig:scattering-angles]" rid="figU003Ascattering-angles">[fig:scattering-angles]</xref>),
  the axes are denoted <inline-formula><alternatives>
  <tex-math><![CDATA[\hat{x}']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
  <inline-formula><alternatives>
  <tex-math><![CDATA[\hat{y}']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mi>y</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
  and <inline-formula><alternatives>
  <tex-math><![CDATA[\hat{z}']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mi>z</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>,
  and the <inline-formula><alternatives>
  <tex-math><![CDATA[\hat{y}']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mover><mml:mi>y</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-direction
  is in the direction of the beam. A <inline-formula><alternatives>
  <tex-math><![CDATA[R_x(\alpha_i)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  rotation will move from the sample frame to the lab frame, so in the
  lab frame, the scattered wavevector is</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{split}
      \mathbf{k}_s &= \frac{2\pi}{\lambda} R_x(\alpha_i)R_x(\alpha_s)R_z(\phi_s)\ \hat{y}'\\
      &= \frac{2\pi}{\lambda} R_x(\alpha_s+\alpha_i)R_z(\phi_s)\ \hat{y}'.
  \end{split}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.222em"></mml:mspace><mml:mover><mml:mi>y</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>′</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:msub><mml:mi>R</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mspace width="0.222em"></mml:mspace><mml:mover><mml:mi>y</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>′</mml:mi><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <fig>
    <caption><p>(a) Coordinates in the sample frame. (b) Coordinates in
    the lab
    frame.<styled-content id="figU003Ascattering-angles"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="scattering-angles.png" />
  </fig>
  <p>The scattering angles can then be related to coordinates on the
  detector as seen in Figure
  <xref alt="[fig:scattering-detector]" rid="figU003Ascattering-detector">[fig:scattering-detector]</xref>:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      z'' &= d_{sd} \tan(\alpha_s+\alpha_i)\\
      x'' &= \sqrt{d_{sd}^2+z^2}\tan(\phi_s),
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>z</mml:mi><mml:mi>″</mml:mi></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>tan</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>x</mml:mi><mml:mi>″</mml:mi></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msup><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt><mml:mo>tan</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[z'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>z</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[x'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  are coordinates on the detector with respect to the
  <inline-formula><alternatives>
  <tex-math><![CDATA[x'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-<inline-formula><alternatives>
  <tex-math><![CDATA[z'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>z</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-plane.
  Note: the <inline-formula><alternatives>
  <tex-math><![CDATA[z'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>z</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-direction
  is the same as the <inline-formula><alternatives>
  <tex-math><![CDATA[z']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>z</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-direction,
  but has its origin at the PONI instead of the sample, but the
  <inline-formula><alternatives>
  <tex-math><![CDATA[x'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-direction
  is reversed from the <inline-formula><alternatives>
  <tex-math><![CDATA[x']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-direction.</p>
  <p>Row <inline-formula><alternatives>
  <tex-math><![CDATA[i]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>
  and column <inline-formula><alternatives>
  <tex-math><![CDATA[j]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>j</mml:mi></mml:math></alternatives></inline-formula>
  coordinates can be related to <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{r}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>𝐫</mml:mi></mml:math></alternatives></inline-formula>
  through the equations</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      x'' &= (j_\text{poni} - j)p_x\\
      z'' &= (i_\text{poni} - i)p_z,
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>x</mml:mi><mml:mi>″</mml:mi></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>z</mml:mi><mml:mi>″</mml:mi></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[i_\text{poni}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>i</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[j_\text{poni}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>j</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext></mml:msub></mml:math></alternatives></inline-formula>
  are the row and column index of the PONI respectively, and
  <inline-formula><alternatives>
  <tex-math><![CDATA[p_x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[p_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>p</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  are the horizontal and vertical widths of a rectangular pixel.</p>
  <fig>
    <caption><p>In the lab frame, the scattering angles can be related
    to coordinates (<inline-formula><alternatives>
    <tex-math><![CDATA[x]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[z]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>z</mml:mi></mml:math></alternatives></inline-formula>)
    on the detector relative to the
    PONI.<styled-content id="figU003Ascattering-detector"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="scattering-detector.png" />
  </fig>
  <fig>
    <caption><p>The detector origin is the center of the top-left pixel,
    and <inline-formula><alternatives>
    <tex-math><![CDATA[i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[j]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>j</mml:mi></mml:math></alternatives></inline-formula>
    are the row and column indices respectively. Distances from the PONI
    <inline-formula><alternatives>
    <tex-math><![CDATA[\mathbf{r}=x\;\hat{x}''+z\;\hat{z}'']]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>𝐫</mml:mi><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mspace width="0.278em"></mml:mspace><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>″</mml:mi><mml:mo>+</mml:mo><mml:mi>z</mml:mi><mml:mspace width="0.278em"></mml:mspace><mml:mover><mml:mi>z</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    can also be described by their magnitude
    <inline-formula><alternatives>
    <tex-math><![CDATA[r=\sqrt{x^2+z^2}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>
    and azimuthal angle <inline-formula><alternatives>
    <tex-math><![CDATA[\psi]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ψ</mml:mi></mml:math></alternatives></inline-formula>.<styled-content id="figU003Adetector-origin"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="detector-origin.png" />
  </fig>
</sec>
<sec id="reciprocal-space">
  <title>Reciprocal space</title>
  <p>The scattering vector <inline-formula><alternatives>
  <tex-math><![CDATA[\mathbf{q}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>𝐪</mml:mi></mml:math></alternatives></inline-formula>
  is defined as</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\mathbf{q} = \mathbf{k}_s - \mathbf{k}_i,]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>𝐪</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>and the magnitude of the scattering vector can be related to the
  Bragg angle <inline-formula><alternatives>
  <tex-math><![CDATA[\theta]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>θ</mml:mi></mml:math></alternatives></inline-formula>
  through Bragg’s law: Equation
  (<xref alt="1" rid="eqU003Abragg">1</xref>). The magnitude of the
  scattering vector is also related to a lattice plane spacing
  <inline-formula><alternatives>
  <tex-math><![CDATA[d]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>d</mml:mi></mml:math></alternatives></inline-formula>
  via</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[d = \frac{2\pi}{q}.]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>q</mml:mi></mml:mfrac><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>In the sample frame (Figure
  <xref alt="[fig:scattering-angles]" rid="figU003Ascattering-angles">[fig:scattering-angles]</xref>a),</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      \mathbf{k}_i &= \frac{2\pi}{\lambda}
      \begin{bmatrix}
          0\\
          \cos{\alpha_i}\\
          -\sin{\alpha_i}
      \end{bmatrix},\\
      \mathbf{k}_s &= \frac{2\pi}{\lambda}
      \begin{bmatrix}
          -\sin{\phi_s}\\
          \cos{\alpha_s}\cos{\phi_s}\\
          \sin{\alpha_s}\cos{\phi_s}
      \end{bmatrix},
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mo>cos</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>−</mml:mi><mml:mo>sin</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>−</mml:mi><mml:mo>sin</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mo>cos</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mo>sin</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>so in the sample frame, the scattering vector can be written</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\mathbf{q} = \mathbf{k}_s - \mathbf{k}_i = \frac{2\pi}{\lambda}
      \begin{bmatrix}
          -\sin{\phi_s}\\
          \cos{\alpha_s}\cos{\phi_s} - \cos{\alpha_i}\\
          \sin{\alpha_s}\cos{\phi_s} + \sin{\alpha_i}
      \end{bmatrix}.]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>𝐪</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>𝐤</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mi>−</mml:mi><mml:mo>sin</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mo>cos</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mo>cos</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center" style="text-align: center"><mml:mo>sin</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>sin</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>Many thin films have cylindrical symmetry, in that individual
  crystallites have a preferred orientation of a lattice vector in the
  <inline-formula><alternatives>
  <tex-math><![CDATA[z']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>z</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-direction,
  but are disordered in rotations on the surface of the substrate
  (<xref alt="Breiby et al., 2008" rid="ref-film-texture-sim" ref-type="bibr">Breiby
  et al., 2008</xref>). The cylindrical symmetry of the crystallites
  leads to cylindrical symmetry in reciprocal space, where
  <inline-formula><alternatives>
  <tex-math><![CDATA[q_{xy}=\sqrt{q_x^2+q_y^2}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msubsup><mml:mi>q</mml:mi><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>q</mml:mi><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>
  represents the radial axis. A grazing incidence X-ray image
  transformation into reciprocal space then requires the following
  calculations:</p>
  <p><named-content id="eqU003Aqz" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  \label{eq:qxy}
      q_{xy} &= \frac{2\pi}{\lambda}(\sin^2\phi_s+(\cos{\alpha_s}\cos{\phi_s} - \cos{\alpha_i})^2)\\

      q_z &= \frac{2\pi}{\lambda}(\sin{\alpha_s}\cos{\phi_s} + \sin{\alpha_i}).
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mo>sin</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>cos</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mo>cos</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>q</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow><mml:mi>λ</mml:mi></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>sin</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mo>sin</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
  <p>Equations (<xref alt="[eq:qxy]" rid="eqU003Aqxy">[eq:qxy]</xref>)
  and (<xref alt="3" rid="eqU003Aqz">3</xref>) can be calculated using
  <inline-formula><alternatives>
  <tex-math><![CDATA[\alpha_s]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></alternatives></inline-formula>,
  <inline-formula><alternatives>
  <tex-math><![CDATA[\alpha_i]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>,
  <inline-formula><alternatives>
  <tex-math><![CDATA[\cos\phi_s]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,
  and <inline-formula><alternatives>
  <tex-math><![CDATA[\sin\phi_s]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>sin</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
  as determined by the detector coordinates
  <inline-formula><alternatives>
  <tex-math><![CDATA[x'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[z'']]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>z</mml:mi><mml:mi>″</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  and the sample-detector distance <inline-formula><alternatives>
  <tex-math><![CDATA[d_{sd}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  (Figure
  <xref alt="[fig:scattering-detector]" rid="figU003Ascattering-detector">[fig:scattering-detector]</xref>):</p>
  <p><named-content id="eqU003Asin_phi" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  \label{eq:alpha_s}
      \alpha_s &= \tan^{-1}\bigg(\frac{z''}{d_{sd}}\bigg)-\alpha_i\\
  \label{eq:cos_phi}
      \cos\phi_s & = \sqrt{\frac{z''^2+d_{sd}^2}{x''^2+z''^2+d_{sd}^2}}\\

      \sin\phi_s & = \frac{x''}{\sqrt{x''^2+z''^2+d_{sd}^2}}
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>α</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msup><mml:mo>tan</mml:mo><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">(</mml:mo><mml:mfrac><mml:mrow><mml:mi>z</mml:mi><mml:mi>″</mml:mi></mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mo>cos</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msqrt><mml:mfrac><mml:mrow><mml:mi>z</mml:mi><mml:msup><mml:mi>″</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:msup><mml:mi>″</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>z</mml:mi><mml:msup><mml:mi>″</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:msqrt></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mo>sin</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>x</mml:mi><mml:mi>″</mml:mi></mml:mrow><mml:msqrt><mml:mrow><mml:mi>x</mml:mi><mml:msup><mml:mi>″</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>z</mml:mi><mml:msup><mml:mi>″</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msqrt></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
</sec>
<sec id="reverse-transform">
  <title>Reverse transform</title>
  <p>In order to suffice the agnosticism goal, after GixPy calculates
  <inline-formula><alternatives>
  <tex-math><![CDATA[q_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[q_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>q</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  for each pixel location, it then relates these to
  <inline-formula><alternatives>
  <tex-math><![CDATA[r_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[r_{z}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  such that a powder transformation (utilizing Equation
  (<xref alt="2" rid="eqU003Apowder">2</xref>)) will produce the correct
  results. This is done by reversing the powder transformation:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      r = d_{sd}\tan\bigg[2\sin^{-1}\bigg(\frac{\lambda q}{4\pi}\bigg)\bigg],
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>tan</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">[</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mo>sin</mml:mo><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">(</mml:mo><mml:mfrac><mml:mrow><mml:mi>λ</mml:mi><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:mfrac><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">)</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">]</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[q=\sqrt{q_{xy}^2+q_z^2}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msubsup><mml:mi>q</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>q</mml:mi><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>.
  The following trig identities
  (<xref alt="Spiegel et al., 2012" rid="ref-schaum" ref-type="bibr">Spiegel
  et al., 2012</xref>):</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      \tan2u &= \frac{2\tan u}{1-\tan^2 u}\\
      \tan \bigg[\sin^{-1}\bigg(\frac{u}{2}\bigg)\bigg] &= \frac{u}{\sqrt{4-u^2}},
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mo>tan</mml:mo><mml:mn>2</mml:mn><mml:mi>u</mml:mi></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>tan</mml:mo><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mo>tan</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mi>u</mml:mi></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mo>tan</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">[</mml:mo><mml:msup><mml:mo>sin</mml:mo><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">(</mml:mo><mml:mfrac><mml:mi>u</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">)</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">]</mml:mo></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mi>u</mml:mi><mml:msqrt><mml:mrow><mml:mn>4</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mfrac><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>can be used to show</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      r = d_{sd}q'\frac{\sqrt{4 - q'^2}}{2 - q'^2},
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mi>q</mml:mi><mml:mi>′</mml:mi><mml:mfrac><mml:msqrt><mml:mrow><mml:mn>4</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msup><mml:mi>′</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msup><mml:mi>′</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[q'=\lambda q/4\pi]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>q</mml:mi><mml:mi>′</mml:mi><mml:mo>=</mml:mo><mml:mi>λ</mml:mi><mml:mi>q</mml:mi><mml:mi>/</mml:mi><mml:mn>4</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
  <p>The azimuthal angle <inline-formula><alternatives>
  <tex-math><![CDATA[\psi]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ψ</mml:mi></mml:math></alternatives></inline-formula>
  (as seen in Figures
  <xref alt="[fig:scattering-detector]" rid="figU003Ascattering-detector">[fig:scattering-detector]</xref>
  and
  <xref alt="[fig:detector-origin]" rid="figU003Adetector-origin">[fig:detector-origin]</xref>)
  is related to both <inline-formula><alternatives>
  <tex-math><![CDATA[r]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>r</mml:mi></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[q]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>q</mml:mi></mml:math></alternatives></inline-formula>
  in the same way:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      \cos\psi &= \frac{r_{xy}}{r} = \frac{q_{xy}}{q}\\
      \sin\psi &= \frac{r_z}{r} = \frac{q_z}{q},
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mo>cos</mml:mo><mml:mi>ψ</mml:mi></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mi>r</mml:mi></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mi>q</mml:mi></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mo>sin</mml:mo><mml:mi>ψ</mml:mi></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mi>r</mml:mi></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>q</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mi>q</mml:mi></mml:mfrac><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>so</p>
  <p><named-content id="eqU003Arz" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  \label{eq:rxy}
      r_{xy} &= d_{sd}q'_{xy} \frac{\sqrt{4 - q'^2_{xy} - q'^2_z}}{2 - q'^2_{xy} - q'^2_z}\\

      r_z &= d_{sd} q'_z\frac{\sqrt{4 - q'^2_{xy} - q'^2_z}}{2 - q'^2_{xy} - q'^2_z},
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mi>q</mml:mi><mml:msub><mml:mi>′</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:msqrt><mml:mrow><mml:mn>4</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mi>q</mml:mi><mml:msub><mml:mi>′</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mfrac><mml:msqrt><mml:mrow><mml:mn>4</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:msubsup><mml:mi>′</mml:mi><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[q'_{xy}=\lambda q_{xy}/4\pi]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>q</mml:mi><mml:msub><mml:mi>′</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>λ</mml:mi><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mi>/</mml:mi><mml:mn>4</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[q'_{z}=\lambda q_{z}/4\pi]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>q</mml:mi><mml:msub><mml:mi>′</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>λ</mml:mi><mml:msub><mml:mi>q</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mi>/</mml:mi><mml:mn>4</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
</sec>
<sec id="seeding-the-transformed-image">
  <title>Seeding the transformed image</title>
  <p>For every pixel’s location relative to the PONI, GixPy calculates
  an <inline-formula><alternatives>
  <tex-math><![CDATA[r_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[r_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  using Equations
  (<xref alt="[eq:rxy]" rid="eqU003Arxy">[eq:rxy]</xref>) and
  (<xref alt="5" rid="eqU003Arz">5</xref>) and then creates a new image
  where all the counts from each pixel is moved to a location
  corresponding to <inline-formula><alternatives>
  <tex-math><![CDATA[r_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[r_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  for that pixel. As illustrated in Figure
  <xref alt="[fig:detector-transform]" rid="figU003Adetector-transform">[fig:detector-transform]</xref>,
  the new image will have a PONI corresponding to the maximum value of
  <inline-formula><alternatives>
  <tex-math><![CDATA[r_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[r_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  of all the pixels:</p>
  <p><named-content id="eqU003Aponi-jT" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  \label{eq:poni-iT}
      i^T_\text{poni} &= \text{max}(r_z) / p_z\\

      j^T_\text{poni} &= \text{max}(r_{xy}) / p_x,
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msubsup><mml:mi>i</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext><mml:mi>T</mml:mi></mml:msubsup></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">max</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>/</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msubsup><mml:mi>j</mml:mi><mml:mtext mathvariant="normal">poni</mml:mtext><mml:mi>T</mml:mi></mml:msubsup></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">max</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>/</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
  <p>where <inline-formula><alternatives>
  <tex-math><![CDATA[p_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>p</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[p_x]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>p</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  are the vertical and horizontal widths of a pixel respectively.
  <inline-formula><alternatives>
  <tex-math><![CDATA[r_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[r_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>,
  for each pixel, correspond to row <inline-formula><alternatives>
  <tex-math><![CDATA[i^T]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math></alternatives></inline-formula>
  and column <inline-formula><alternatives>
  <tex-math><![CDATA[j^T]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math></alternatives></inline-formula>
  in the transformed image according to</p>
  <p><named-content id="eqU003AjT" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  \label{eq:iT}
      i^T &= \text{max}(r_z) - r_z\\

      j^T &= \text{max}(r_{xy}) - r_{xy}.
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msup><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">max</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msup><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">max</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mi>.</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
  <p>The transformed image will have rows <inline-formula><alternatives>
  <tex-math><![CDATA[R^T]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>R</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math></alternatives></inline-formula>
  and columns <inline-formula><alternatives>
  <tex-math><![CDATA[C^T]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>C</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math></alternatives></inline-formula>
  as determined by</p>
  <p><named-content id="eqU003AcolsT" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  \label{eq:rowsT}
      R^T &= \text{ceil}(\text{max}(r_z) - \text{min}(r_z)) + 1\\

      C^T &= \text{ceil}(\text{max}(r_{xy})- \text{min}(r_{xy})) + 1,
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msup><mml:mi>R</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">ceil</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="normal">max</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mtext mathvariant="normal">min</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msup><mml:mi>C</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mtext mathvariant="normal">ceil</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mtext mathvariant="normal">max</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mtext mathvariant="normal">min</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
  <p>where the minimums are negatively valued if the PONI is on the
  detector, <inline-formula><alternatives>
  <tex-math><![CDATA[\text{ceil}(x)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mtext mathvariant="normal">ceil</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is the ceiling function, and the extra 1 is padding to guarantee that
  there is room for the pixel splitting step. The transformed image is
  seeded by creating a NumPy array of zeros with shape
  <inline-formula><alternatives>
  <tex-math><![CDATA[(R^T,\ C^T)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>R</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.222em"></mml:mspace><mml:msup><mml:mi>C</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.
  To account for how many pixels are moved to a new pixel location, a
  second NumPy array, referred to as the transformed flat field is also
  created.</p>
  <fig>
    <caption><p>The transformed image’s PONI and shape can be determined
    by the minimums and maximuns of the <inline-formula><alternatives>
    <tex-math><![CDATA[r_{xy}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[r_z]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    found in the transformation
    calculation.<styled-content id="figU003Adetector-transform"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="detector-transform.png" />
  </fig>
</sec>
<sec id="pixel-splitting">
  <title>Pixel splitting</title>
  <p>A pixel index is determined by flooring
  <inline-formula><alternatives>
  <tex-math><![CDATA[i^T]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[j^T]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:math></alternatives></inline-formula>,
  and the counts are split amongst that pixel’s neighbors, as seen in
  Figure
  <xref alt="[fig:pixel-split]" rid="figU003Apixel-split">[fig:pixel-split]</xref>.
  Remainders <inline-formula><alternatives>
  <tex-math><![CDATA[\rho]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ρ</mml:mi></mml:math></alternatives></inline-formula>
  are determined by</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
      \rho_i &= i^T - \text{floor}(i^T)\\
      \rho_j &= j^T - \text{floor}(j^T),
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mtext mathvariant="normal">floor</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>ρ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mtext mathvariant="normal">floor</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
  <p>and the counts get distributed according to following weights</p>
  <p><named-content id="eqU003Aw4" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[\begin{aligned}
  \label{eq:w1}
      w_\text{current pixel} &= (1-\rho_i)(1-\rho_j)\\
  \label{eq:w2}
      w_\text{column neighbor} &= (1-\rho_i)\rho_j\\
  \label{eq:w3}
      w_\text{row neighbor} &= \rho_i(1-\rho_j)\\

      w_\text{diagonal neighbor} &= \rho_i\rho_j,
  \end{aligned}]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>w</mml:mi><mml:mtext mathvariant="normal">current pixel</mml:mtext></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>w</mml:mi><mml:mtext mathvariant="normal">column neighbor</mml:mtext></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>w</mml:mi><mml:mtext mathvariant="normal">row neighbor</mml:mtext></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>w</mml:mi><mml:mtext mathvariant="normal">diagonal neighbor</mml:mtext></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>ρ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></named-content></p>
  <p>where the sum of the weights adds to 1. It is clear that when the
  remainders are zero, then the “current pixel” gets all the counts, and
  when both remainders are 0.5, all the pixels get 1/4 the counts.</p>
  <fig>
    <caption><p>The counts are split amongst neighboring
    pixels.<styled-content id="figU003Apixel-split"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="pixel-split.png" />
  </fig>
</sec>
<sec id="moving-pixels">
  <title>Moving pixels</title>
  <p>Every pixel in the original image is looped over, and the new row
  and column indices <inline-formula><alternatives>
  <tex-math><![CDATA[(i^T,\ j^T)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.222em"></mml:mspace><mml:msup><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  are determined using Equations
  (<xref alt="[eq:iT]" rid="eqU003AiT">[eq:iT]</xref>) and
  (<xref alt="7" rid="eqU003AjT">7</xref>) by first calculating
  scattering angles using Equations
  (<xref alt="[eq:alpha_s]" rid="eqU003Aalpha_s">[eq:alpha_s]</xref>) to
  (<xref alt="4" rid="eqU003Asin_phi">4</xref>). Then
  <inline-formula><alternatives>
  <tex-math><![CDATA[q_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>q</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[q_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>q</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  are computed with Equations
  (<xref alt="[eq:qxy]" rid="eqU003Aqxy">[eq:qxy]</xref>) and
  (<xref alt="3" rid="eqU003Aqz">3</xref>),
  <inline-formula><alternatives>
  <tex-math><![CDATA[r_{xy}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives>
  <tex-math><![CDATA[r_z]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  with Equations (<xref alt="[eq:rxy]" rid="eqU003Arxy">[eq:rxy]</xref>)
  and (<xref alt="5" rid="eqU003Arz">5</xref>), and the new PONI and
  image shape with Equations
  (<xref alt="[eq:poni-iT]" rid="eqU003Aponi-iT">[eq:poni-iT]</xref>),
  (<xref alt="6" rid="eqU003Aponi-jT">6</xref>),
  (<xref alt="[eq:rowsT]" rid="eqU003ArowsT">[eq:rowsT]</xref>), and
  (<xref alt="8" rid="eqU003AcolsT">8</xref>). The weights are
  calculated for each pixel using Equations
  (<xref alt="[eq:w1]" rid="eqU003Aw1">[eq:w1]</xref>) to
  (<xref alt="9" rid="eqU003Aw4">9</xref>), and the counts in pixel
  <inline-formula><alternatives>
  <tex-math><![CDATA[(i,\ j)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.222em"></mml:mspace><mml:mi>j</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  from the original image are added to the counts in pixel
  <inline-formula><alternatives>
  <tex-math><![CDATA[(i^T,\ j^T)]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mspace width="0.222em"></mml:mspace><mml:msup><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  and its neighbors according to the pixel splitting weights. This is
  executed by compiled C code written in gixpy.c, but a Pythonic version
  of this step would look like:</p>
  <code language="python">new_image = np.zeros((R_T, C_T))  # as determined by Eq (34) and (35)
new_flatfield = np.zeros((R_T, C_T))
for i in range(image.shape[0]):      # loop over rows of the original image
    for j in range(image.shape[1]):  # loop over columns of the original image
        new_i = int(i_T[i, j])       # floor of i^T, as calculated by Eq (32)
        new_j = int(j_T[i, j])       # floor of j^T, as calculated by Eq (33)
        
        # calculate weights
        remainder_i = i_T[i, j] - new_i  # Eq (36)
        remainder_j = j_T[i, j] - new_j  # Eq (37)
        w_current_pixel = (1 - remainder_i) * (1 - remainder_j)  # Eq (38)
        w_column_neighbor = (1 - remainder_i) * remainder_j      # Eq (39)
        w_row_neighbor = remainder_i * (1 - remainder_j)         # Eq (40)
        w_diagonal_neighbor = remainder_i * remainder_j          # Eq (41)

        # split pixel
        new_image[new_i, new_j] += image[i, j] * w_current_pixel
        new_image[new_i + 1, new_j] += image[i, j] * w_row_neighbor
        new_image[new_i, new_j + 1] += image[i, j] * w_column_neighbor
        new_image[new_i + 1, new_j + 1] += image[i, j] * w_diagonal_neighbor

        # account for pixel movement
        new_flatfield[new_i, new_j] += w_current_pixel
        new_flatfield[new_i + 1, new_j] += w_row_neighbor
        new_flatfield[new_i, new_j + 1] += w_column_neighbor
        new_flatfield[new_i + 1, new_j + 1] += w_diagonal_neighbor</code>
</sec>
<sec id="flat-field-correction">
  <title>Flat-field correction</title>
  <p>A flat-field correction is used to compensate for relative gains of
  each pixel
  (<xref alt="Rowlands &amp; Yorkston, 2000" rid="ref-medical-imaging" ref-type="bibr">Rowlands
  &amp; Yorkston, 2000</xref>). A corrected image
  <inline-formula><alternatives>
  <tex-math><![CDATA[C]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>C</mml:mi></mml:math></alternatives></inline-formula>
  is computed from the raw data <inline-formula><alternatives>
  <tex-math><![CDATA[R]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>R</mml:mi></mml:math></alternatives></inline-formula>
  and a flat-field image <inline-formula><alternatives>
  <tex-math><![CDATA[F]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>F</mml:mi></mml:math></alternatives></inline-formula>,
  where the flat-field values represent the relative sensitivity of each
  pixel:</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[C = \frac{R}{F}.]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>R</mml:mi><mml:mi>F</mml:mi></mml:mfrac><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>A flat field should be used to correct for pixels that are more or
  less sensitive than the average pixel, and/or if mulitple images are
  stitched together such that there are regions of the stitch that have
  more or less exposure time than average. For example. Regardless of
  whether or not a flat-field correction is needed for the original
  image, a flat-field correction will always be needed for the GIXS
  transformation.</p>
  <p>As can be seen in Figure
  <xref alt="[fig:flat-waxs]" rid="figU003Aflat-waxs">[fig:flat-waxs]</xref>,
  the transformation results in a <italic>missing wedge</italic>
  (<xref alt="Baker et al., 2010" rid="ref-quantify-film-alignment" ref-type="bibr">Baker
  et al., 2010</xref>). Pixels moved out of the missing wedge
  disportionately move to the edge of the wedge. This results in these
  pixels, in the transformation, being more sensitive than pixels not
  near the edge of the wedge.</p>
  <fig>
    <caption><p>This image was generated by transforming an array of
    ones with shape <inline-formula><alternatives>
    <tex-math><![CDATA[(2000,\ 3000)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>2000</mml:mn><mml:mo>,</mml:mo><mml:mspace width="0.222em"></mml:mspace><mml:mn>3000</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    using <inline-formula><alternatives>
    <tex-math><![CDATA[75 \times 75]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>75</mml:mn><mml:mo>×</mml:mo><mml:mn>75</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    μm pixels, a detector distance of <inline-formula><alternatives>
    <tex-math><![CDATA[150]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>150</mml:mn></mml:math></alternatives></inline-formula>
    mm, and a grazing-incidence angle of <inline-formula><alternatives>
    <tex-math><![CDATA[0.3^{\circ}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mn>0.3</mml:mn><mml:mo>∘</mml:mo></mml:msup></mml:math></alternatives></inline-formula>.<styled-content id="figU003Aflat-waxs"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="GIWAXS-transform.png" />
  </fig>
  <p>The extra brightness along this edge is corrected by also
  transforming the original image’s flat field. An array of ones will
  represent the flat-field image for an image that needs no correction.
  The result of a GIXS transform will then yield both an array for the
  data image and for the flat-field image, where the transformed
  flat-field image can be used to correct for the edge brightness.</p>
</sec>
<sec id="solid-angle-correction">
  <title>Solid-angle correction</title>
  <p>X-rays generated by X-ray tube sources lose intensity according to
  the inverse square law. Since a flat area detector is used to detect
  the scattered rays, rays that are detected further from the beam
  center will lose more intensity than those detected near the beam
  center. The distance a ray travels <inline-formula><alternatives>
  <tex-math><![CDATA[d_\text{ray}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mtext mathvariant="normal">ray</mml:mtext></mml:msub></mml:math></alternatives></inline-formula>
  to the detector is determined by the sample-detector distance
  <inline-formula><alternatives>
  <tex-math><![CDATA[d_{sd}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  and the scattering angle <inline-formula><alternatives>
  <tex-math><![CDATA[2\theta]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  (as seen in Figure
  <xref alt="[fig:waxs]" rid="figU003Awaxs">[fig:waxs]</xref>).</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[d_{sd} = d_\text{ray} \cos{2\theta}.]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mtext mathvariant="normal">ray</mml:mtext></mml:msub><mml:mo>cos</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>The intensity of a ray that travels a distance
  <inline-formula><alternatives>
  <tex-math><![CDATA[d_\text{ray}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mtext mathvariant="normal">ray</mml:mtext></mml:msub></mml:math></alternatives></inline-formula>
  relative to its intensity after traveling a distance
  <inline-formula><alternatives>
  <tex-math><![CDATA[d_{sd}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  is then</p>
  <p><disp-formula><alternatives>
  <tex-math><![CDATA[\frac{I({d_\text{ray}})}{I({d_{sd}})} = \bigg(\frac{d_{sd}}{d_\text{ray}}\bigg)^2 =  \cos^2{2\theta}.]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>I</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mtext mathvariant="normal">ray</mml:mtext></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>I</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">(</mml:mo><mml:mfrac><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>d</mml:mi><mml:mtext mathvariant="normal">ray</mml:mtext></mml:msub></mml:mfrac><mml:msup><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">)</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mo>cos</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
  <p>Furthermore, the angle of incidence of the ray makes with the
  detector will be the same as the scattering angle and will result in a
  further attenuation of <inline-formula><alternatives>
  <tex-math><![CDATA[\cos{2\theta}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>cos</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
  Therefore, rays that hit the detector will lose intensity according to
  <inline-formula><alternatives>
  <tex-math><![CDATA[\cos^3{2\theta}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mo>cos</mml:mo><mml:mn>3</mml:mn></mml:msup><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
  A solid angle correction reverses this attentuation by multiplying the
  counts in pixels by <inline-formula><alternatives>
  <tex-math><![CDATA[\Omega]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Ω</mml:mi></mml:math></alternatives></inline-formula>,
  where</p>
  <p><named-content id="eqU003Asolid-angle" content-type="equation"><disp-formula><alternatives>
  <tex-math><![CDATA[
      \Omega = \sec^3{2\theta}.]]></tex-math>
  <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Ω</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mo>sec</mml:mo><mml:mn>3</mml:mn></mml:msup><mml:mrow><mml:mn>2</mml:mn><mml:mi>θ</mml:mi></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></named-content></p>
  <p>The solid-angle correction will then adjust the intensity of pixels
  to the amount of counts the detector would see if its surface wrapped
  a sphere around the sample. This is often desired to compare to data
  that would be collected by a diffractometer.</p>
  <p>Since the solid-angle correction is relative to the geometry of the
  original image, it is best to apply the solid-angle correction during
  the transformation, and it should <italic>NOT</italic> be applied to
  the transformed image.</p>
  <fig>
    <caption><p>The solid-angle correction increases the intensity of
    pixels as a function of scattering angle to compensate for the
    inverse square law and the angle of incedence of a
    pixel.<styled-content id="figU003Asolid-angle-correction"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="GIWAXS-transform-SAC.png" />
  </fig>
</sec>
</body>
<back>
<ref-list>
  <title>Refrences</title>
  <ref id="ref-pyfai">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Kieffer</surname><given-names>Jérôme</given-names></name>
        <name><surname>Ashiotis</surname><given-names>Giannis</given-names></name>
      </person-group>
      <article-title>PyFAI: A python library for high performance azimuthal integration on GPU</article-title>
      <source>Powder Diffraction</source>
      <year iso-8601-date="2013">2013</year>
      <uri>http://arxiv.org/abs/1412.6367</uri>
    </element-citation>
  </ref>
  <ref id="ref-nika">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Ilavsky</surname><given-names>Jan</given-names></name>
      </person-group>
      <article-title>Nika: Software for two-dimensional data reduction</article-title>
      <source>Journal of Applied Crystallography</source>
      <year iso-8601-date="2012-04">2012</year><month>04</month>
      <volume>45</volume>
      <issue>2</issue>
      <uri>https://doi.org/10.1107/S0021889812004037</uri>
      <pub-id pub-id-type="doi">10.1107/S0021889812004037</pub-id>
      <fpage>324</fpage>
      <lpage>328</lpage>
    </element-citation>
  </ref>
  <ref id="ref-cullity3rd">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Cullity</surname><given-names>B. D.</given-names></name>
        <name><surname>Stock</surname><given-names>S. R.</given-names></name>
      </person-group>
      <source>Elements of x-ray diffraction</source>
      <publisher-name>Pearson Education Limited</publisher-name>
      <year iso-8601-date="2014">2014</year>
      <edition>3rd</edition>
      <isbn>1269374508</isbn>
    </element-citation>
  </ref>
  <ref id="ref-film-texture-sim">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Breiby</surname><given-names>Dag W.</given-names></name>
        <name><surname>Bunk</surname><given-names>Oliver</given-names></name>
        <name><surname>Andreasen</surname><given-names>Jens W.</given-names></name>
        <name><surname>Lemke</surname><given-names>Henrik T.</given-names></name>
        <name><surname>Nielsen</surname><given-names>Martin M.</given-names></name>
      </person-group>
      <article-title>Simulating x-ray diffraction of textured films</article-title>
      <source>Journal of Applied Crystallography</source>
      <year iso-8601-date="2008-03">2008</year><month>03</month>
      <volume>41</volume>
      <pub-id pub-id-type="doi">10.1107/S0021889808001064</pub-id>
      <fpage>262</fpage>
      <lpage>271</lpage>
    </element-citation>
  </ref>
  <ref id="ref-schaum">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Spiegel</surname><given-names>Murray R.</given-names></name>
        <name><surname>Lipschutz</surname><given-names>Seymour</given-names></name>
        <name><surname>Liu</surname><given-names>John</given-names></name>
      </person-group>
      <source>Mathematical handbook of formulas and tables</source>
      <publisher-name>McGraw-Hill Education</publisher-name>
      <year iso-8601-date="2012">2012</year>
      <edition>4th</edition>
    </element-citation>
  </ref>
  <ref id="ref-how-to-giwaxs">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Steele</surname><given-names>Julian A.</given-names></name>
        <name><surname>Solano</surname><given-names>Eduardo</given-names></name>
        <name><surname>Hardy</surname><given-names>David</given-names></name>
        <name><surname>Dayton</surname><given-names>Damara</given-names></name>
        <name><surname>Ladd</surname><given-names>Dylan</given-names></name>
        <name><surname>White</surname><given-names>Keith</given-names></name>
        <name><surname>Chen</surname><given-names>Peng</given-names></name>
        <name><surname>Hou</surname><given-names>Jingwei</given-names></name>
        <name><surname>Huang</surname><given-names>Haowei</given-names></name>
        <name><surname>Saha</surname><given-names>Rafikul Ali</given-names></name>
        <name><surname>Wang</surname><given-names>Lianzhou</given-names></name>
        <name><surname>Gao</surname><given-names>Feng</given-names></name>
        <name><surname>Hofkens</surname><given-names>Johan</given-names></name>
        <name><surname>Roeffaers</surname><given-names>Maarten B. J.</given-names></name>
        <name><surname>Chernyshov</surname><given-names>Dmitry</given-names></name>
        <name><surname>Toney</surname><given-names>Michael F.</given-names></name>
      </person-group>
      <article-title>How to GIWAXS: Grazing incidence wide angle x-ray scattering applied to metal halide perovskite thin films</article-title>
      <source>Advanced Energy Materials</source>
      <publisher-name>John Wiley; Sons Inc</publisher-name>
      <year iso-8601-date="2023-07">2023</year><month>07</month>
      <volume>13</volume>
      <pub-id pub-id-type="doi">10.1002/aenm.202300760</pub-id>
    </element-citation>
  </ref>
  <ref id="ref-medical-imaging">
    <element-citation publication-type="chapter">
      <person-group person-group-type="author">
        <name><surname>Rowlands</surname><given-names>John A</given-names></name>
        <name><surname>Yorkston</surname><given-names>John</given-names></name>
      </person-group>
      <article-title>Flat panel detectors for digital radiography</article-title>
      <source>Handbook of Medical Imaging</source>
      <person-group person-group-type="editor">
        <name><surname>Metter</surname><given-names>Richard L Van</given-names></name>
        <name><surname>Beutel</surname><given-names>Jacob</given-names></name>
        <name><surname>Kundel</surname><given-names>Harold L</given-names></name>
      </person-group>
      <publisher-name>SPIE</publisher-name>
      <year iso-8601-date="2000">2000</year>
      <volume>1</volume>
      <uri>http://spiedl.org/terms</uri>
      <fpage>223</fpage>
      <lpage>328</lpage>
    </element-citation>
  </ref>
  <ref id="ref-quantify-film-alignment">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Baker</surname><given-names>Jessy L.</given-names></name>
        <name><surname>Jimison</surname><given-names>Leslie H.</given-names></name>
        <name><surname>Mannsfeld</surname><given-names>Stefan</given-names></name>
        <name><surname>Volkman</surname><given-names>Steven</given-names></name>
        <name><surname>Yin</surname><given-names>Shong</given-names></name>
        <name><surname>Subramanian</surname><given-names>Vivek</given-names></name>
        <name><surname>Salleo</surname><given-names>Alberto</given-names></name>
        <name><surname>Alivisatos</surname><given-names>A. Paul</given-names></name>
        <name><surname>Toney</surname><given-names>Michael F.</given-names></name>
      </person-group>
      <article-title>Quantification of thin film crystallographic orientation using x-ray diffraction with an area detector</article-title>
      <source>Langmuir</source>
      <year iso-8601-date="2010-06">2010</year><month>06</month>
      <volume>26</volume>
      <pub-id pub-id-type="doi">10.1021/la904840q</pub-id>
      <fpage>9146</fpage>
      <lpage>9151</lpage>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>
